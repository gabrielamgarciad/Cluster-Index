multi.which = function(A){
#https://www.r-bloggers.com/2011/09/a-multidimensional-which-function/
    if ( is.vector(A) ) return(which(A))
    d <- dim(A)
    T <- which(A) - 1
    nd <- length(d)
    t( sapply(T, function(t){
        I <- integer(nd)
        I[1] <- t %% d[1]
        sapply(2:nd, function(j){
            I[j] <<- (t %/% prod(d[1:(j-1)])) %% d[j]
        })
        I
    }) + 1 )
}


spherePix = function(vox,Rmax){
  require(pracma)
  start_time = Sys.time()
  vox=vox/min(vox)
  MG = meshgrid(-Rmax:Rmax,-Rmax:Rmax)
  X = array(MG$X,dim=c(length(-Rmax:Rmax),length(-Rmax:Rmax),length(-Rmax:Rmax)))
  Y = array(MG$Y,dim=c(length(-Rmax:Rmax),length(-Rmax:Rmax),length(-Rmax:Rmax)))
  Z = array(rep(-Rmax:Rmax,each=length(-Rmax:Rmax)^2),dim=c(length(-Rmax:Rmax),length(-Rmax:Rmax),length(-Rmax:Rmax)))
  pxls = matrix(c(0,0,0,0),1,4)
 
  for(r in seq(0,Rmax,by=0.01)){
    circle = ((X*vox[1])^2 + (Y*vox[2])^2 + (Z*vox[3])^2 <= r^2)*((X*vox[1])^2 + (Y*vox[2])^2 + (Z*vox[3])^2 > (r-0.01)^2)
    x = as.vector(X/circle);x = x[is.finite(x)];
    y = as.vector(Y/circle);y = y[is.finite(y)];
    z = as.vector(Z/circle);z = z[is.finite(z)];
    pxls = rbind(pxls,matrix(c(rep(r,length(x)),x,y,z),length(x),4))
    #print(round(r/Rmax,2))
  }
end_time = Sys.time()
print('SpherePix calculation time: ')
print(end_time-start_time)
return(pxls)
}


px2vec = function(i,j,k,A){i + (j-1)*dim(A)[1] + (k-1)*dim(A)[1]*dim(A)[2]}
vec2px = function(n,A){s = ceiling(n/(dim(A)[1]*dim(A)[2]));n = n - (s-1)*(dim(A)[2]*dim(A)[1]);c = ceiling(n/dim(A)[1]);r = n - (c-1)*dim(A)[1];return(c(r,c,s))}

calculateDDI = function(defectArray,vox,Rmax,...){
  z = list(...)
  cutoff = 0.5
  mrr = 0
  if(!is.null(z$cutoff)){cutoff = z$cutoff;}
   
 
  ## -- find list of sphere pixels given voxel dimensions
  spherePx = spherePix(vox,Rmax)
 
  ## -- create a list of all defect voxels, and convert that list to a vector -- ##
  defList = multi.which(defectArray==1)
  defVec = px2vec(defList[,1],defList[,2],defList[,3],defectArray)
 
 ## -- create a DDI array to store calculated DDI values
  DDI = defectArray*0
 
  ## -- What are all the indices in the 'spherePx' matrix at which there is a change in radius? Find out and store in sphereRads -- ##
  sphereRads = unique((diff(spherePx[,1])>0)*(2:dim(spherePx)[1]));sphereRads = sphereRads[sphereRads>0]-1
 
  ## -- for every defect Voxel, lets grow a sphere and find out the fraction of defect voxels within the sphere -- ##
  maxR = 0
  start_time = Sys.time()
  for(k in 1:dim(defList)[1]){
    #print(paste0(k,'/',dim(defList)[1]))
 
    ## - pull a defect voxel row/col/slice to examine
    r0 = defList[k,1]
    c0 = defList[k,2]
    s0 = defList[k,3]
    sphereVec = px2vec(spherePx[,2]+r0,spherePx[,3]+c0,spherePx[,4]+s0,defectArray)
 
    ## - Let's increase the radius and see what fraction of sphere voxels contain defect voxels
    for(ii in sphereRads){
      ## - what fraction of voxels within the sphere are defect?
      C = length(intersect(sphereVec[1:ii],defVec))/length(sphereVec[1:ii])
 
      ## - if that fraction is less than half, break the radius loop
      if(C<cutoff){break}
    }
 
  ## - what radius did we get to before breaking the loop? store that radius in the DDI array at our defect voxel location
  DDI[r0,c0,s0] = spherePx[ii,1]
  maxR = spherePx[ii,1]*(spherePx[ii,1]>maxR) + maxR*(spherePx[ii,1]<=maxR)
  if(ii==max(sphereRads)){print('MAX RADIUS REACHED');mrr=1;}
  #print(paste0('Max Radius: ',maxR)) #If this number gets up to the max sphere radius in spherePx you may need to run again with bigger spherePx matrix
  end_time = Sys.time()
  }
print('DDI calculation time: ')
print(end_time-start_time)
print(paste0('Max Radius: ',maxR))
return(list(DDI = DDI,maxR=maxR,mrr=mrr))
}


require(pracma)

mg = meshgrid(1:100,1:100)
X = array(mg$X, dim = c(100,100,100))
Y = array(mg$Y, dim = c(100,100,100))
Z = array(rep(1:100, each = 100*100), dim = c(100,100,100))
circle = ((X-50)^2 + (Y-50)^2 + (Z-50)^2) < 40^2

mymask = mask[14:100,,]
circle = array(0,dim=c(100,100,100))
circle[1:87, 1:88, 1:60]=mymask
#makeSlide(circle)

#using mask from the following path: C:\Users\gmg9r2\OneDrive - University of Missouri\Manuscripts\CI_method\DataAnalysis\230428_VDPanalysis\CF_rfiles\CF_partB_VDP_Subj 13.RData
#####################--------------------Spheres with same VDP but different distribution of defects-------------#####################
##Same VDP, same Radius, different clusters

#vdp_values = numeric(length(N_values) * repetitions)

#N = 10
#size = (50-N):(50+N)
#repetitions= 2
#NN= c(10)
NN = c(1,2,3,4,5,6,7,8,9,10,15,20,30,40)
noisyCircles = array(0,dim=c(100,100,100,3,14))
vdps = array(NA,dim=c(14,3))


	for (N in 1:14){
  	  size = (50-NN[N]):(50+NN[N])
		 noiseF = array(0,dim=c(100,100,100))
     	  for (rep in 1:dim(noisyCircles)[4]){
		    vdp=0
      	     while((vdp > 0.505) || (vdp < 0.495)){
      	          noiseF[size,size,size] = complex(real = array(rnorm(length(size)^3,0,1),dim = c(length(size),length(size),length(size))),imaginary = array(rnorm(length(size)^3,0,1),dim = c(length(size),length(size),length(size))))
       	         noise = fft(quadShift3D(noiseF),inverse=TRUE)
       	         noisyCircle = circle*(Re(noise)>0)
        	        vdp = sum(noisyCircle)/sum(circle)
        	        print(vdp)
        	   }#while
		vdps[N,rep] = vdp
		noisyCircles[,,,rep,N] = noisyCircle
		#print(paste('Completed rep:',rep,' -- N:',N))
		#makeSlide(noisyCircle)           
  	  }#for rep


vox = c(3.9,3.9,3.9)
save(noisyCircles, vdps, vox, file='C:\\Users\\gmg9r2\\OneDrive - University of Missouri\\Manuscripts\\CI_method\\DataAnalysis\\230428_VDPanalysis\\noisycirlces_lungsVDP\\231102_noisyCircles_lungs.RData')

}#for N




path = 'C:\\Users\\gmg9r2\\OneDrive - University of Missouri\\Manuscripts\\CI_method\\DataAnalysis\\230428_VDPanalysis\\noisycirlces_lungsVDP\\'
Rfile = dir(path, pattern = '.RData', full.name=T)
Rfile_name = dir(path, pattern = '.RData', full.name=F)

results = array(NA, dim=c(14,3,4))
CIarrays = noisyCircles*0
CVvolume = noisyCircles*0
results[,,1] = vdps

for (n in 1:dim(noisyCircles)[5]){
    for(r in 1:dim(noisyCircles)[4]){
	previous = load(Rfile)

	A = calculateDDI(noisyCircles[,,,r,n],vox,60)
	CIarrays[,,,r,n] = A$DDI
	CVvol = (A$DDI*min(vox))^3*(4*pi/3) # - convert distance to volume
	CVvolume[,,,r,n] = CVvol
	LungVolume = sum(circle)*prod(vox) # - calculate volume of lung
	CVlist = CVvol[(noisyCircles[,,,r,n])>0] # - make list of CV's
	CVlist = CVlist[order(CVlist)] # - sort list of CV's
	CI = CVlist[round(0.95*length(CVlist))]/LungVolume*100 # - CI is 95th percentile value (normalize to lung volume)
	results[n,r,1] = vdps
	results[n,r,2] = CI
	results[n,r,3] = A$maxR
	results[n,r,4] = LungVolume
      save(list = c(previous),CIarrays,CVvolume, results, file='C:\\Users\\gmg9r2\\OneDrive - University of Missouri\\Manuscripts\\CI_method\\DataAnalysis\\230428_VDPanalysis\\noisycirlces_lungsVDP\\231102_noisylungs_CI.RData')
	} #for r
} #for n


